# Overview
A simple replica of the Google Dino game made with a simple neural network to learn to play the game.

# Associated Paper
The complex system that I chose to study was networks, specifically neural networks used for machine learning. The project that I made relating to neural networks is a replica of Google Chome’s Dino game, but with a unique twist; the dino is a frog and the cacti are rocks (and the game is in color). There are five files that make the simulation work and I will detail what each file does in this paper. All of the files that go into making this simulation work are written in Python and use the Pygame, SciPy, NumPy, and Random modules. The files are as follows: 

dino.py &emsp;:&emsp; 	runs the simulation.  
var.py &emsp;:&emsp; 	contains all of the global definitions.  
nnet.py &emsp;:&emsp;     contains the Nnet object class that is responsible for part of the machine learning.  
rock.py &emsp;:&emsp; 	houses the Rock and RockCollection object classes and their related methods.  
frog.py  &emsp;:&emsp; 	houses the Frog and FrogCollection object classes and their associated methods, including the genetic algorithm.  


## Dino
This is the main file that sets up and runs the simulation. In this file, there are three functions: updateLabel(), updateDataLabels(), and runGame(). All of these files are just responsible for running the simulation/game and displaying the labels that appear on the screen; these labels include the FPS(frames-per-second), Game Time(time spent in the current iteration of the game), Iteration(the iteration or generation of Frogs), Alive(the number of Frogs alive), and Score.

## Var
This file just has all of the global constant variables that should be accessed throughout the project, like the size of the screen, rocks, frog, the values for the neural network, etc. They are separated into categories based on where they are used for the sake of ease when modifying the simulation. These categories include Window, Rock, Frog, Neural Network, Fitness, and Genetic Algorithm and Mutations.

## Rock
The rock.py file contains the classes, Rock and RockCollection. The Rock class defines the obstacles that appear on the screen and scroll toward the Frog. The RockCollection class defines a collection of Rock objects stored in a list and has methods to add new Rock objects, create a series of Rock obstacles across the screen with random height and gap sizes, update the positions of each Rock, and remove the rocks that have passed the Frog off the screen. Together, these two classes have all of the methods necessary to create the rocks on the screen and make the game scroll.

## Nnet
The nnet.py file is where the neural network is defined and where the methods to perform the computations are stored. The Nnet object has attributes for the number of nodes in each layer(input, hidden, and output), the weights for the input to the hidden layer, weights for the output of the hidden layer, and the activation function. In this case, the activation function is a sigmoid function that is obtained using the SciPy module. All of the weights are initially random and can be modified randomly by using the modifyWeights() method; this method is used in the mutation process. Additionally, there is the createMixedWeights() method that gets a mix of the weights of two different networks and returns the “child” of the two networks. This method is utilized in the genetic algorithm for breeding the Frog objects. Finally, there is the getAvgOutput() method that returns the average of the values obtained by the hidden layer; the value that this method returns is what decides if the Frog jumps or not.

## Frog
The frog.py file contains the classes, Frog and FrogCollection. The Frog class contains the code to create a Frog, display it on the screen, make it move(jump), and check for collisions. Additionally, this class contains helper methods for those functions, but the overall purpose of this object is to contain the code necessary to display the Frog and make it move. Most importantly, this class has the necessary attributes for the machine learning processes included in the FrogCollection class. These include nnet which is a Nnet object and a fitness attribute to store the overall determined fitness of the Frog. Next, there is the FrogCollection class which is essentially just that, a collection of Frog objects with methods like evolvePopulation() and createNewGeneration() that are essential to applying the genetic algorithm on the FrogCollection and creating the next generation of Frogs. The genetic algorithm is encapsulated in the evolvePopulation() method and works by first taking the list of Frog objects and sorting them by their fitness. The fitness of the individual Frog is determined by the assignCollisionFitness() method in the Frog class as well as the total time the Frog spent alive. Once the list of Frogs is sorted by fitness, the list is split at a specified cutoff point and becomes two separate lists: goodFrogs and badFrogs. The goodFrogs are taken and put into the list of frogs for the next generation. Next, the method takes a certain percentage of the bad Frogs and mutates them by randomizing a certain percent of their weights and puts them in a list to be put in the next generation. To fill up any remaining spaces in the list for the next generation, the method performs a breeding algorithm that utilizes the createMixedWeights() method from the Nnet class to get a mix of the weights from the Nnets of any two “good” Frogs. This algorithm puts children of the “good” Frogs in the list of Frogs for the next generation until the generation size requirement is met. All of this together makes up the frog.py file.

## Conclusion
Overall, I really enjoyed working on this project. I think that I learned a lot about machine learning and neural networks as well as some programming fundamentals. It was nice to revisit object-oriented programming and utilize some of the knowledge that I have there. It was also really interesting to make a game and significantly harder than I imagined. There are so many complexities that I didn’t even consider prior to doing this project regarding the just fundamentals of the simulation, like just getting the objects to move on the screen and defining some of their behaviors(and that wasn’t even the hard part). Calculating the inputs was also challenging at first, but once I understood more about the window is laid out, it became a little more clear how to calculate it. I also learned a lot from modifying the constants in the var.py file through research and trial and error. A significant portion of time went into experimenting with the neural network and adjusting the fitness function to make the simulation run quicker and have the population learn quicker. The video series that I watched that gave me the inspiration for this helped significantly in the overall process of making this project, but there was also a lot of individual exploring involved in adapting it to work with this replica of the Dino game. This project has been my favorite project that I have gotten to work on for a class and while the freedom that I had when choosing a complex system to study was very daunting at first, I’m glad I got to apply it to something that I was individually interested in. 
